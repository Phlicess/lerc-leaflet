<!DOCTYPE html>
  <html>
  <head>
    <meta charset=utf-8 />
    <title>Lerc in Leaflet</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />

    <!-- Load Leaflet from CDN-->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.0.2/dist/leaflet.css" />
    <script src="https://unpkg.com/leaflet@1.0.2/dist/leaflet-src.js"></script>

    <!-- load esri leaflet and its geocoder for address/place search -->
    <script src="https://unpkg.com/esri-leaflet@2.0.6"></script>
    <link rel="stylesheet" href="https://unpkg.com/esri-leaflet-geocoder@2.2.2/dist/esri-leaflet-geocoder.css">
    <script src="https://unpkg.com/esri-leaflet-geocoder@2.2.2"></script>

    <!--load the lerc decoder -->
    <script src="https://cdn.rawgit.com/Esri/lerc/v1.0/OtherLanguages/js/LercDecode.js"></script>

    <!-- slider library-->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/8.2.1/nouislider.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/8.2.1/nouislider.min.js"></script>

    <style>
      body {
        margin:0;
        padding:0;
      }

      #map {
        position: absolute;
        top:0;
        bottom:0;
        right:0;left:0;
      }

      #info-pane {
        position: absolute;
        top: 10px;
        right: 10px;
        min-width: 200px;
        z-index: 500;
        padding: 1em;
        background: white;
      }

      .noUi-connect {
        background: #CCC;
      }
    </style>
  </head>
  <body>

  <div id="map"></div>
  <div id="info-pane" class="leaflet-bar">
    <div id="slider"></div>
    <br>
    <label id="min">
    0 meters
    </label><br>
    <label id="max">
    4000 meters
    </label>

    <hr>

    <div id="pixel-value"></div>
  </div>

  <script>

    // create a UI slider for the end user to toggle the pixel range to display
    var slider = document.getElementById('slider');
    noUiSlider.create(slider, {
      start: [0, 4000],
      step: 100,
      connect: true,
      range: { 'min': 0, 'max': 8000  }
    });

    // When the slider value changes, update the input and span
    slider.noUiSlider.on('set', function (values, handle) {
      document.getElementById('min').innerHTML = parseInt(values[0], 10) + ' meters';
      document.getElementById('max').innerHTML = parseInt(values[1], 10) + ' meters';
      // redraw the tiles without resetting
      for (t in lerc._tiles)
        lerc._redrawTile(lerc._tiles[t]);
    });

    var southWest = L.latLng(-90, -179),
    northEast = L.latLng(90, 179),
    worldBounds = L.latLngBounds(southWest, northEast);

    var map = L.map('map', {
      noWrap: true,
      minZoom: 3,
      maxBounds: worldBounds
    }).setView([30, 45], 3);

    var LercLayer = L.GridLayer.extend({
      createTile: function (coords, done) {
        var error;
        var tile = L.DomUtil.create('canvas', 'leaflet-tile');
        tile.width = 256;
        tile.height = 256;

        var xhr = new XMLHttpRequest();
        xhr.responseType = "arraybuffer";
        var url = 'https://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/' + 'Terrain3D/ImageServer/tile/' + coords.z + '/' + coords.y + '/' + coords.x;

        xhr.open("Get", url, true);
        xhr.send();
        xhr.onreadystatechange = function () {
          if (this.readyState == 4 && this.status == 200) {
            tile.decodedPixels = Lerc.decode(xhr.response);
            // LercLayer.draw(tile.decodedPixels);
            var width = tile.decodedPixels.width - 1;
            var height = tile.decodedPixels.height - 1;
            var min = slider.noUiSlider.get()[0];
            var max = slider.noUiSlider.get()[1];
            var pixels = tile.decodedPixels.pixels[0];
            var mask = tile.decodedPixels.maskData;

            var ctx = tile.getContext('2d');
            var imageData = ctx.createImageData(width, height);
            var data = imageData.data;
            var f = 256 / (max - min);
            var pv = 0;
            for (var i = 0; i < width * height; i++) {
              // Skip the last pixel in each input line
              var j = i + Math.floor(i / width);
              pv = (pixels[j] - min) * f;
              data[i * 4] = pv;
              data[i * 4 + 1] = pv;
              data[i * 4 + 2] = pv;
              // Mask only gets returned when missing data exists
              data[i * 4 + 3] = (mask && !mask[j]) ? 0 : 255;
            }
            ctx.putImageData(imageData, 0, 0);
            //
            done(error, tile);
          }
        }
        return tile;
      }
    });

    var elevation = new LercLayer({
      noWrap: true,
      attribution: 'USGS, Esri <a href="https://github.com/Esri/lerc">LERC</a>'
    });

    map.on('mousemove', function (e) {
      // the x/y of the tile url
      var layerPoint = map.project(e.latlng).floor();
      var tilePoint = layerPoint.divideBy(256).floor();
      tilePoint.z = map.getZoom();
      // the tile data block
      var block = elevation._tiles[tilePoint.x + ':' + tilePoint.y + ':' + tilePoint.z].el.decodedPixels;

      // Read the data value from the block if it exists
      if (block) {
        var pointInTile = layerPoint.subtract(tilePoint.multiplyBy(256));
        document.getElementById('pixel-value').innerHTML = "current elevation: " +
                 Math.round(block.pixels[0][pointInTile.y * block.width + pointInTile.x]) + " meters";
      } else {
        document.getElementById('pixel-value').innerHTML = "Elevation: undefined";
      }
    });

    //  lercLayer.options.reuseTiles = true;

    L.esri.Geocoding.geosearch().addTo(map);
    elevation.addTo(map);

  </script>
  </body>
  </html>
