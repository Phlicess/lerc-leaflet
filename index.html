<!DOCTYPE html>
  <html>
  <head>
    <meta charset=utf-8 />
    <title>Lerc in Leaflet</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />

    <!-- Load Leaflet from CDN-->
    <link rel="stylesheet" href="//cdn.leafletjs.com/leaflet/v0.7.7/leaflet.css" />
    <script src="//cdn.leafletjs.com/leaflet/v0.7.7/leaflet.js"></script>

    <script src="//rawgit.com/Esri/lerc/master/js/LercCodec.js"></script>

    <style>
      body {
        margin:0;
        padding:0;
      }

      #map {
        position: absolute;
        top:0;
        bottom:0;
        right:0;left:0;
      }

      #info-pane {
        position: absolute;
        top: 10px;
        right: 10px;
        z-index: 10;
        padding: 1em;
        background: white;
      }
    </style>
  </head>
  <body>

  <div id="map"></div>
  <div id="info-pane" class="leaflet-bar">
    <label>
    pixel range (m)
    </label>
    <input id="pixelRangeMin" type="text" value="0" onchange="lerc.redraw()">
    <input id="pixelRangeMax" type="text" value="8000" onchange="lerc.redraw()">

    <hr>

    <div id="pixel-value"></div>
  </div>

  <script>
    var url;

    var map = L.map('map', {
      noWrap: true
    }).setView([40, -100], 3);

    var lerc = L.tileLayer.canvas({
      noWrap: true,
      attribution: 'USGS, Esri <a href="https://github.com/Esri/lerc">LERC</a>'
    });

    var drawData = function(lercblob, ctx) {
      var width = lercblob.width -1;
      var height = lercblob.height -1;
      var min = document.getElementById('pixelRangeMin').value;
      var max = document.getElementById('pixelRangeMax').value;
      var pixels = lercblob.pixelData;
      var mask = lercblob.maskData;

      var imageData = ctx.createImageData(width, height);
      var data = imageData.data;
      var f = 256 / (max - min);
      var pv = 0;
      for (var i = 0; i < width * height; i++) {
        // Skip the last pixel in each input line
        var j = i + Math.floor(i / width);
        pv = (pixels[j] - min) * f;
        data[i * 4] = pv;
        data[i * 4 + 1] = pv;
        data[i * 4 + 2] = pv;
        // Mask only gets returned when missing data exists
        data[i * 4 + 3] = (mask && !mask[j]) ? 0 :255;
      }
      ctx.putImageData(imageData, 0, 0);
    }

    lerc.drawTile = function(canvas, tilePoint, zoom) {
      var ctx = canvas.getContext('2d');

      var tile = lerc._tiles[tilePoint.x + ':' + tilePoint.y];
      var lerco = LERC();
      if (tile.decodedPixels) {
        // This would save time, but it doesn't seem to ever happen
        drawData(tile.decodedPixels, ctx);
      } else {
        var xhr = new XMLHttpRequest();
        xhr.responseType = "arraybuffer";
        var url = '//elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer/tile/' +
        zoom + '/' + tilePoint.y + '/' + tilePoint.x;
        xhr.open("Get", url, true);
        xhr.send();
        xhr.onreadystatechange = function () {
          if (xhr.readyState == 4 && xhr.status == 200) {
            var decodedPixelBlock = lerco.decode(xhr.response, { returnMask: true });
            tile.decodedPixels = decodedPixelBlock;
            drawData(decodedPixelBlock, ctx);
          }
        }
      }
    }

    map.on('mousemove', function (e) {
      // the x/y of the tile url
      var layerPoint = map.project(e.latlng).floor();
      var tilePoint = layerPoint.divideBy(256).floor();

      // the actual <canvas> object
      var block = lerc._tiles[tilePoint.x + ':' + tilePoint.y].decodedPixels;

      // if we have a tile
      if (block) {
        var pointInTile = layerPoint.subtract(tilePoint.multiplyBy(256));

        // extract the pixel data from the canvas
        document.getElementById('pixel-value').innerHTML = "Elevation: " +
                 block.pixelData[pointInTile.y * block.width + pointInTile.x] + " m";
      } else {
        document.getElementById('pixel-value').innerHTML = "Elevation: undefined";
      }
    })

    lerc.addTo(map);
  </script>
  </body>
  </html>
