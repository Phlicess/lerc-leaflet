<!DOCTYPE html>
  <html>
  <head>
    <meta charset=utf-8 />
    <title>Lerc in Leaflet</title>
    <meta name='viewport' content='initial-scale=1,maximum-scale=1,user-scalable=no' />

    <!-- Load Leaflet from CDN-->
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/leaflet/0.7.7/leaflet.css" />
    <script src="https://cdn.jsdelivr.net/leaflet/0.7.7/leaflet.js"></script>

    <!-- load esri leaflet and its geocoder for place search -->
    <script src="https://cdn.jsdelivr.net/leaflet.esri/1.0.2/esri-leaflet.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/leaflet.esri.geocoder/1.0.2/esri-leaflet-geocoder.css" />
    <script src="https://cdn.jsdelivr.net/leaflet.esri.geocoder/1.0.2/esri-leaflet-geocoder.js"></script>

    <script src="https://rawgit.com/Esri/lerc/master/js/LercCodec.js"></script>

    <!-- slider library-->
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/8.2.1/nouislider.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/noUiSlider/8.2.1/nouislider.min.js"></script>

    <style>
      body {
        margin:0;
        padding:0;
      }

      #map {
        position: absolute;
        top:0;
        bottom:0;
        right:0;left:0;
      }

      #info-pane {
        position: absolute;
        top: 10px;
        right: 10px;
        min-width: 200px;
        z-index: 10;
        padding: 1em;
        background: white;
      }

      .noUi-connect {
        background: #CCC;
      }
    </style>
  </head>
  <body>

  <div id="map"></div>
  <div id="info-pane" class="leaflet-bar">
    <div id="slider"></div>
    <br>
    <label id="min">
    0 meters
    </label><br>
    <label id="max">
    4000 meters
    </label>

    <hr>

    <div id="pixel-value"></div>
  </div>

  <script>

    // create a UI slider for the end user to toggle the pixel range to display
    var slider = document.getElementById('slider');
    noUiSlider.create(slider, {
      start: [0, 4000],
      step: 100,
      connect: true,
      range: {
        'min': 0,
        'max': 8000
      }
    });

    // When the slider value changes, update the input and span
    slider.noUiSlider.on('set', function (values, handle) {
      document.getElementById('min').innerHTML = parseInt(values[0], 10) + ' meters';
      document.getElementById('max').innerHTML = parseInt(values[1], 10) + ' meters';
      // redraw the tiles without resetting
      for (t in lerc._tiles)
        lerc._redrawTile(lerc._tiles[t]);
    });

    var southWest = L.latLng(-90, -179),
    northEast = L.latLng(90, 179),
    worldBounds = L.latLngBounds(southWest, northEast);

    var map = L.map('map', {
      noWrap: true,
      minZoom: 3,
      maxBounds: worldBounds
    }).setView([30, 45], 3);

    var lerc = L.tileLayer.canvas({
      noWrap: true,
      attribution: 'USGS, Esri <a href="https://github.com/Esri/lerc">LERC</a>'
    });

    lerc.codec = LERC();

    lerc.drawTile = function (canvas, tilePoint, zoom) {

      drawData = function (lercblob, ctx) {
        var width = lercblob.width - 1;
        var height = lercblob.height - 1;
        var min = slider.noUiSlider.get()[0];
        var max = slider.noUiSlider.get()[1];
        var pixels = lercblob.pixelData;
        var mask = lercblob.maskData;

        var imageData = ctx.createImageData(width, height);
        var data = imageData.data;
        var f = 256 / (max - min);
        var pv = 0;
        for (var i = 0; i < width * height; i++) {
          // Skip the last pixel in each input line
          var j = i + Math.floor(i / width);
          pv = (pixels[j] - min) * f;
          data[i * 4] = pv;
          data[i * 4 + 1] = pv;
          data[i * 4 + 2] = pv;
          // Mask only gets returned when missing data exists
          data[i * 4 + 3] = (mask && !mask[j]) ? 0 : 255;
        }
        ctx.putImageData(imageData, 0, 0);
      }

      var tileIndex = tilePoint.x + ':' + tilePoint.y;
      var tile = this._tiles[tileIndex];
      if (tile.decodedPixels) {
        drawData(tile.decodedPixels, canvas.getContext('2d'));
        return;
      }

      var xhr = new XMLHttpRequest();
      xhr.responseType = "arraybuffer";
      xhr.codec = this.codec
      var url = 'http://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer/tile/' +
	zoom + '/' + tilePoint.y + '/' + tilePoint.x;

      xhr.open("Get", url, true);
      xhr.send();
      xhr.onreadystatechange = function () {
        if (this.readyState == 4 && this.status == 200) {
          tile.decodedPixels = this.codec.decode(xhr.response, { returnMask: true });
          drawData(tile.decodedPixels, canvas.getContext('2d'));
        }
      }
    };

    map.on('mousemove', function (e) {
      // the x/y of the tile url
      var layerPoint = map.project(e.latlng).floor();
      var tilePoint = layerPoint.divideBy(256).floor();
      // the tile data block
      var block = lerc._tiles[tilePoint.x + ':' + tilePoint.y].decodedPixels;

      // Read the data value from the block if it exists
      if (block) {
        var pointInTile = layerPoint.subtract(tilePoint.multiplyBy(256));
        document.getElementById('pixel-value').innerHTML = "current elevation: " +
                 block.pixelData[pointInTile.y * block.width + pointInTile.x] + " meters";
      } else {
        document.getElementById('pixel-value').innerHTML = "Elevation: undefined";
      }
    })

//    lerc.options.reuseTiles = true;

    L.esri.Geocoding.Controls.geosearch().addTo(map);
    lerc.addTo(map);

  </script>
  </body>
  </html>
